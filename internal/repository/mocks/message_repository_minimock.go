// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mocks

//go:generate minimock -i chat-server/internal/repository.MessageRepository -o message_repository_minimock.go -n MessageRepositoryMock -p mocks

import (
	"chat-server/internal/model"
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// MessageRepositoryMock implements repository.MessageRepository
type MessageRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, model model.Message) (err error)
	inspectFuncCreate   func(ctx context.Context, model model.Message)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mMessageRepositoryMockCreate

	funcDelete          func(ctx context.Context, id int64, user_id int64) (err error)
	inspectFuncDelete   func(ctx context.Context, id int64, user_id int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mMessageRepositoryMockDelete

	funcGetChat          func(ctx context.Context, chat_id int64) (ma1 []model.Message, err error)
	inspectFuncGetChat   func(ctx context.Context, chat_id int64)
	afterGetChatCounter  uint64
	beforeGetChatCounter uint64
	GetChatMock          mMessageRepositoryMockGetChat
}

// NewMessageRepositoryMock returns a mock for repository.MessageRepository
func NewMessageRepositoryMock(t minimock.Tester) *MessageRepositoryMock {
	m := &MessageRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mMessageRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*MessageRepositoryMockCreateParams{}

	m.DeleteMock = mMessageRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*MessageRepositoryMockDeleteParams{}

	m.GetChatMock = mMessageRepositoryMockGetChat{mock: m}
	m.GetChatMock.callArgs = []*MessageRepositoryMockGetChatParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mMessageRepositoryMockCreate struct {
	mock               *MessageRepositoryMock
	defaultExpectation *MessageRepositoryMockCreateExpectation
	expectations       []*MessageRepositoryMockCreateExpectation

	callArgs []*MessageRepositoryMockCreateParams
	mutex    sync.RWMutex
}

// MessageRepositoryMockCreateExpectation specifies expectation struct of the MessageRepository.Create
type MessageRepositoryMockCreateExpectation struct {
	mock    *MessageRepositoryMock
	params  *MessageRepositoryMockCreateParams
	results *MessageRepositoryMockCreateResults
	Counter uint64
}

// MessageRepositoryMockCreateParams contains parameters of the MessageRepository.Create
type MessageRepositoryMockCreateParams struct {
	ctx   context.Context
	model model.Message
}

// MessageRepositoryMockCreateResults contains results of the MessageRepository.Create
type MessageRepositoryMockCreateResults struct {
	err error
}

// Expect sets up expected params for MessageRepository.Create
func (mmCreate *mMessageRepositoryMockCreate) Expect(ctx context.Context, model model.Message) *mMessageRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("MessageRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &MessageRepositoryMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &MessageRepositoryMockCreateParams{ctx, model}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the MessageRepository.Create
func (mmCreate *mMessageRepositoryMockCreate) Inspect(f func(ctx context.Context, model model.Message)) *mMessageRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for MessageRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by MessageRepository.Create
func (mmCreate *mMessageRepositoryMockCreate) Return(err error) *MessageRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("MessageRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &MessageRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &MessageRepositoryMockCreateResults{err}
	return mmCreate.mock
}

// Set uses given function f to mock the MessageRepository.Create method
func (mmCreate *mMessageRepositoryMockCreate) Set(f func(ctx context.Context, model model.Message) (err error)) *MessageRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the MessageRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the MessageRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the MessageRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mMessageRepositoryMockCreate) When(ctx context.Context, model model.Message) *MessageRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("MessageRepositoryMock.Create mock is already set by Set")
	}

	expectation := &MessageRepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &MessageRepositoryMockCreateParams{ctx, model},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up MessageRepository.Create return parameters for the expectation previously defined by the When method
func (e *MessageRepositoryMockCreateExpectation) Then(err error) *MessageRepositoryMock {
	e.results = &MessageRepositoryMockCreateResults{err}
	return e.mock
}

// Create implements repository.MessageRepository
func (mmCreate *MessageRepositoryMock) Create(ctx context.Context, model model.Message) (err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, model)
	}

	mm_params := MessageRepositoryMockCreateParams{ctx, model}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := MessageRepositoryMockCreateParams{ctx, model}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("MessageRepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the MessageRepositoryMock.Create")
		}
		return (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, model)
	}
	mmCreate.t.Fatalf("Unexpected call to MessageRepositoryMock.Create. %v %v", ctx, model)
	return
}

// CreateAfterCounter returns a count of finished MessageRepositoryMock.Create invocations
func (mmCreate *MessageRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of MessageRepositoryMock.Create invocations
func (mmCreate *MessageRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to MessageRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mMessageRepositoryMockCreate) Calls() []*MessageRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*MessageRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *MessageRepositoryMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *MessageRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MessageRepositoryMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MessageRepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to MessageRepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to MessageRepositoryMock.Create")
	}
}

type mMessageRepositoryMockDelete struct {
	mock               *MessageRepositoryMock
	defaultExpectation *MessageRepositoryMockDeleteExpectation
	expectations       []*MessageRepositoryMockDeleteExpectation

	callArgs []*MessageRepositoryMockDeleteParams
	mutex    sync.RWMutex
}

// MessageRepositoryMockDeleteExpectation specifies expectation struct of the MessageRepository.Delete
type MessageRepositoryMockDeleteExpectation struct {
	mock    *MessageRepositoryMock
	params  *MessageRepositoryMockDeleteParams
	results *MessageRepositoryMockDeleteResults
	Counter uint64
}

// MessageRepositoryMockDeleteParams contains parameters of the MessageRepository.Delete
type MessageRepositoryMockDeleteParams struct {
	ctx     context.Context
	id      int64
	user_id int64
}

// MessageRepositoryMockDeleteResults contains results of the MessageRepository.Delete
type MessageRepositoryMockDeleteResults struct {
	err error
}

// Expect sets up expected params for MessageRepository.Delete
func (mmDelete *mMessageRepositoryMockDelete) Expect(ctx context.Context, id int64, user_id int64) *mMessageRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("MessageRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &MessageRepositoryMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &MessageRepositoryMockDeleteParams{ctx, id, user_id}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the MessageRepository.Delete
func (mmDelete *mMessageRepositoryMockDelete) Inspect(f func(ctx context.Context, id int64, user_id int64)) *mMessageRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for MessageRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by MessageRepository.Delete
func (mmDelete *mMessageRepositoryMockDelete) Return(err error) *MessageRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("MessageRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &MessageRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &MessageRepositoryMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the MessageRepository.Delete method
func (mmDelete *mMessageRepositoryMockDelete) Set(f func(ctx context.Context, id int64, user_id int64) (err error)) *MessageRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the MessageRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the MessageRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the MessageRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mMessageRepositoryMockDelete) When(ctx context.Context, id int64, user_id int64) *MessageRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("MessageRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &MessageRepositoryMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &MessageRepositoryMockDeleteParams{ctx, id, user_id},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up MessageRepository.Delete return parameters for the expectation previously defined by the When method
func (e *MessageRepositoryMockDeleteExpectation) Then(err error) *MessageRepositoryMock {
	e.results = &MessageRepositoryMockDeleteResults{err}
	return e.mock
}

// Delete implements repository.MessageRepository
func (mmDelete *MessageRepositoryMock) Delete(ctx context.Context, id int64, user_id int64) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id, user_id)
	}

	mm_params := MessageRepositoryMockDeleteParams{ctx, id, user_id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := MessageRepositoryMockDeleteParams{ctx, id, user_id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("MessageRepositoryMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the MessageRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id, user_id)
	}
	mmDelete.t.Fatalf("Unexpected call to MessageRepositoryMock.Delete. %v %v %v", ctx, id, user_id)
	return
}

// DeleteAfterCounter returns a count of finished MessageRepositoryMock.Delete invocations
func (mmDelete *MessageRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of MessageRepositoryMock.Delete invocations
func (mmDelete *MessageRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to MessageRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mMessageRepositoryMockDelete) Calls() []*MessageRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*MessageRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *MessageRepositoryMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *MessageRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MessageRepositoryMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MessageRepositoryMock.Delete")
		} else {
			m.t.Errorf("Expected call to MessageRepositoryMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to MessageRepositoryMock.Delete")
	}
}

type mMessageRepositoryMockGetChat struct {
	mock               *MessageRepositoryMock
	defaultExpectation *MessageRepositoryMockGetChatExpectation
	expectations       []*MessageRepositoryMockGetChatExpectation

	callArgs []*MessageRepositoryMockGetChatParams
	mutex    sync.RWMutex
}

// MessageRepositoryMockGetChatExpectation specifies expectation struct of the MessageRepository.GetChat
type MessageRepositoryMockGetChatExpectation struct {
	mock    *MessageRepositoryMock
	params  *MessageRepositoryMockGetChatParams
	results *MessageRepositoryMockGetChatResults
	Counter uint64
}

// MessageRepositoryMockGetChatParams contains parameters of the MessageRepository.GetChat
type MessageRepositoryMockGetChatParams struct {
	ctx     context.Context
	chat_id int64
}

// MessageRepositoryMockGetChatResults contains results of the MessageRepository.GetChat
type MessageRepositoryMockGetChatResults struct {
	ma1 []model.Message
	err error
}

// Expect sets up expected params for MessageRepository.GetChat
func (mmGetChat *mMessageRepositoryMockGetChat) Expect(ctx context.Context, chat_id int64) *mMessageRepositoryMockGetChat {
	if mmGetChat.mock.funcGetChat != nil {
		mmGetChat.mock.t.Fatalf("MessageRepositoryMock.GetChat mock is already set by Set")
	}

	if mmGetChat.defaultExpectation == nil {
		mmGetChat.defaultExpectation = &MessageRepositoryMockGetChatExpectation{}
	}

	mmGetChat.defaultExpectation.params = &MessageRepositoryMockGetChatParams{ctx, chat_id}
	for _, e := range mmGetChat.expectations {
		if minimock.Equal(e.params, mmGetChat.defaultExpectation.params) {
			mmGetChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChat.defaultExpectation.params)
		}
	}

	return mmGetChat
}

// Inspect accepts an inspector function that has same arguments as the MessageRepository.GetChat
func (mmGetChat *mMessageRepositoryMockGetChat) Inspect(f func(ctx context.Context, chat_id int64)) *mMessageRepositoryMockGetChat {
	if mmGetChat.mock.inspectFuncGetChat != nil {
		mmGetChat.mock.t.Fatalf("Inspect function is already set for MessageRepositoryMock.GetChat")
	}

	mmGetChat.mock.inspectFuncGetChat = f

	return mmGetChat
}

// Return sets up results that will be returned by MessageRepository.GetChat
func (mmGetChat *mMessageRepositoryMockGetChat) Return(ma1 []model.Message, err error) *MessageRepositoryMock {
	if mmGetChat.mock.funcGetChat != nil {
		mmGetChat.mock.t.Fatalf("MessageRepositoryMock.GetChat mock is already set by Set")
	}

	if mmGetChat.defaultExpectation == nil {
		mmGetChat.defaultExpectation = &MessageRepositoryMockGetChatExpectation{mock: mmGetChat.mock}
	}
	mmGetChat.defaultExpectation.results = &MessageRepositoryMockGetChatResults{ma1, err}
	return mmGetChat.mock
}

// Set uses given function f to mock the MessageRepository.GetChat method
func (mmGetChat *mMessageRepositoryMockGetChat) Set(f func(ctx context.Context, chat_id int64) (ma1 []model.Message, err error)) *MessageRepositoryMock {
	if mmGetChat.defaultExpectation != nil {
		mmGetChat.mock.t.Fatalf("Default expectation is already set for the MessageRepository.GetChat method")
	}

	if len(mmGetChat.expectations) > 0 {
		mmGetChat.mock.t.Fatalf("Some expectations are already set for the MessageRepository.GetChat method")
	}

	mmGetChat.mock.funcGetChat = f
	return mmGetChat.mock
}

// When sets expectation for the MessageRepository.GetChat which will trigger the result defined by the following
// Then helper
func (mmGetChat *mMessageRepositoryMockGetChat) When(ctx context.Context, chat_id int64) *MessageRepositoryMockGetChatExpectation {
	if mmGetChat.mock.funcGetChat != nil {
		mmGetChat.mock.t.Fatalf("MessageRepositoryMock.GetChat mock is already set by Set")
	}

	expectation := &MessageRepositoryMockGetChatExpectation{
		mock:   mmGetChat.mock,
		params: &MessageRepositoryMockGetChatParams{ctx, chat_id},
	}
	mmGetChat.expectations = append(mmGetChat.expectations, expectation)
	return expectation
}

// Then sets up MessageRepository.GetChat return parameters for the expectation previously defined by the When method
func (e *MessageRepositoryMockGetChatExpectation) Then(ma1 []model.Message, err error) *MessageRepositoryMock {
	e.results = &MessageRepositoryMockGetChatResults{ma1, err}
	return e.mock
}

// GetChat implements repository.MessageRepository
func (mmGetChat *MessageRepositoryMock) GetChat(ctx context.Context, chat_id int64) (ma1 []model.Message, err error) {
	mm_atomic.AddUint64(&mmGetChat.beforeGetChatCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChat.afterGetChatCounter, 1)

	if mmGetChat.inspectFuncGetChat != nil {
		mmGetChat.inspectFuncGetChat(ctx, chat_id)
	}

	mm_params := MessageRepositoryMockGetChatParams{ctx, chat_id}

	// Record call args
	mmGetChat.GetChatMock.mutex.Lock()
	mmGetChat.GetChatMock.callArgs = append(mmGetChat.GetChatMock.callArgs, &mm_params)
	mmGetChat.GetChatMock.mutex.Unlock()

	for _, e := range mmGetChat.GetChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ma1, e.results.err
		}
	}

	if mmGetChat.GetChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChat.GetChatMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChat.GetChatMock.defaultExpectation.params
		mm_got := MessageRepositoryMockGetChatParams{ctx, chat_id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChat.t.Errorf("MessageRepositoryMock.GetChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChat.GetChatMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChat.t.Fatal("No results are set for the MessageRepositoryMock.GetChat")
		}
		return (*mm_results).ma1, (*mm_results).err
	}
	if mmGetChat.funcGetChat != nil {
		return mmGetChat.funcGetChat(ctx, chat_id)
	}
	mmGetChat.t.Fatalf("Unexpected call to MessageRepositoryMock.GetChat. %v %v", ctx, chat_id)
	return
}

// GetChatAfterCounter returns a count of finished MessageRepositoryMock.GetChat invocations
func (mmGetChat *MessageRepositoryMock) GetChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChat.afterGetChatCounter)
}

// GetChatBeforeCounter returns a count of MessageRepositoryMock.GetChat invocations
func (mmGetChat *MessageRepositoryMock) GetChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChat.beforeGetChatCounter)
}

// Calls returns a list of arguments used in each call to MessageRepositoryMock.GetChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChat *mMessageRepositoryMockGetChat) Calls() []*MessageRepositoryMockGetChatParams {
	mmGetChat.mutex.RLock()

	argCopy := make([]*MessageRepositoryMockGetChatParams, len(mmGetChat.callArgs))
	copy(argCopy, mmGetChat.callArgs)

	mmGetChat.mutex.RUnlock()

	return argCopy
}

// MinimockGetChatDone returns true if the count of the GetChat invocations corresponds
// the number of defined expectations
func (m *MessageRepositoryMock) MinimockGetChatDone() bool {
	for _, e := range m.GetChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetChatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChat != nil && mm_atomic.LoadUint64(&m.afterGetChatCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetChatInspect logs each unmet expectation
func (m *MessageRepositoryMock) MinimockGetChatInspect() {
	for _, e := range m.GetChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MessageRepositoryMock.GetChat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetChatCounter) < 1 {
		if m.GetChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MessageRepositoryMock.GetChat")
		} else {
			m.t.Errorf("Expected call to MessageRepositoryMock.GetChat with params: %#v", *m.GetChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChat != nil && mm_atomic.LoadUint64(&m.afterGetChatCounter) < 1 {
		m.t.Error("Expected call to MessageRepositoryMock.GetChat")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MessageRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetChatInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MessageRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MessageRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetChatDone()
}
